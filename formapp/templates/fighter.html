<!-- Created by Oley Birkeland -->

{% extends 'header.html' %}
<!-- ^^ This means add this file to the end of the contents of header.html -->
<!-- This is where the title, top buttons, and stylesheet is located -->

<!-- Change title here -->
{% block title %}Turn-Cringe Fighter{% endblock %}

<!-- Extra style declarations here -->
{% block style %}
  <style>
    :root {
      --attack-x: 0;
      --attack-y: 0;
    }

    body, #content {
      background: var(--bg-dark);
      color: white;
      font: 16px "Segoe UI", sans-serif;
      user-select: none;
    }

    ::-webkit-scrollbar {
      width: 15px;
      height: 15px;
    }

    ::-webkit-scrollbar-thumb {
      box-shadow: inset 0 0 5px 5px;
      border: solid 5px transparent;
    }

    ::-webkit-scrollbar-thumb:hover {
      box-shadow: inset 0 0 5px 5px;
    }

    ::-webkit-scrollbar-thumb:active {
      box-shadow: inset 0 0 15px 15px;
      border: none;
    }

    ::-webkit-scrollbar-corner {
      box-shadow: inset 0 0 5px 5px;
      border: solid 5px transparent;
    }

    div, h1, input[type="text"], button, iframe {
      position: absolute;
      box-sizing: border-box;
    }

    h1 {
      margin: 0;
      font-size: 48px;
    }

    h2 {
      margin: 0;
      font-size: 32px;
    }

    h3 {
      margin: 0;
      font-size: 20px;
    }

    h4 {
      margin: 0;
      font-size: 16px;
    }

    button {
      width: 112px;
      height: 40px;
      border-radius: 20px;
      background: transparent;
      color: var(--light-green);
      border: 1px solid;
      font: 18px "Segoe UI", sans-serif;
      cursor: pointer;
    }

    button:not(.unselectable):not(.on):hover {
      background: var(--bg-dark-highlight);
    }

    #randomButton {
      position: relative;
      margin-top: 8px;
    }

    .randomIcon {
      height: 16px;
      vertical-align: -1px;
    }

    input[type="text"] {
      width: 160px;
      height: 40px;
      padding: 4px;
      background: var(--bg-darker);
      color: white;
      border: 1px solid;
      font: 18px "Segoe UI", sans-serif;
      text-align: center;
    }

    input[type="text"]:focus {
      outline: 1px solid white;
    }

    input[type="checkbox"] {
    	-webkit-appearance: none;
      width: 14px;
      height: 14px;
      margin: 3px 6px 3px 0;
      background: var(--bg-darker);
      color: white;
      border: 1px solid;
    	border-radius: 0%;
      vertical-align: text-bottom;
    }

    input[type="checkbox"]:checked {
      background: var(--light-green) url("{{ url_for('static', filename='img/fighter/checkMark.png') }}") no-repeat;
      background-size: 100%;
      color: var(--light-green);
    }

    input[type="checkbox"]:hover, input[type="checkbox"]:checked:hover {
      box-shadow: 0 0 4px;
    }

    #border > * {
      position: fixed;
      width: 50%;
      height: 50%;
      border-width: 8px;
    }

    #topLeftBorder {
      top: 0;
      left: 0;
      border-style: solid none none solid;
      border-color: var(--color-red);
    }

    #topRightBorder {
      top: 0;
      right: 0;
      border-style: solid solid none none;
      border-color: var(--color-yellow);
    }

    #bottomLeftBorder {
      bottom: 0;
      left: 0;
      border-style: none none solid solid;
      border-color: var(--color-green);
    }

    #bottomRightBorder {
      bottom: 0;
      right: 0;
      border-style: none solid solid none;
      border-color: var(--color-blue);
    }

    .hidden {
      display: none;
    }

    .fullScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 8px;
    }

    .hCentered {
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    .vCentered {
      top: 50%;
      transform: translateY(-50%);
    }

    .hCentered.vCentered {
      transform: translate(-50%, -50%);
    }

    .large {
      font-size: 18px;
    }

    .targetOption:hover {
      cursor: pointer;
      filter: drop-shadow(0 0 6px white);
    }

    .unselectable {
      opacity: 50%;
      cursor: not-allowed;
    }

    .fighter {
      width: 450px;
      height: 280px;
      padding: 8px;
      border-radius: 8px;
      color: var(--bg-dark);
      font-size: 14px;
    }

    .red {
      background: #fbb;
    }

    .yellow {
      background: #ffb;
    }

    .green {
      background: #bfb;
    }

    .blue {
      background: #bdf;
    }

    .orange {
      background: #fc9;
    }

    .magenta {
      background: #fbf;
    }

    .gray {
      background: #ddd;
    }

    .gold {
      background: linear-gradient(to bottom right, #fea, #ba4, #fea, #ba4);
    }

    .effect:not(.hidden) {
      position: static;
      display: inline-block;
      padding: 2px 4px;
      color: white;
      border: 1px solid;
      cursor: help;
    }

    .fighterEffects {
      right: 8px;
      top: 9px;
    }

    .fighterEffects > .effect {
      border-color: var(--bg-dark);
    }

    .HPBar {
      position: static;
      width: 75%;
      height: 12px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
      border: 1px solid var(--bg-dark);
      border-radius: 6px;
      background: var(--color-green);
    }

    .showHPChange {
      animation: showHPChange 1.5s;
    }

    @keyframes showHPChange {
      0% {
        opacity: 0;
      }
      33% {
        opacity: 1;
      }
      67% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    .move {
      position: relative;
      left: -8px;
      width: 100%;
      box-sizing: content-box;
      padding: 4px 8px;
      margin: 4px 0;
    }

    .move.enabled {
      cursor: pointer;
    }

    .move.enabled:hover {
      background: #0003;
    }

    .chargeSquare {
      position: static;
      width: 8px;
      height: 8px;
      display: inline-block;
      vertical-align: middle;
      margin: 2px;
      border: 1px solid var(--dark-gray);
    }

    .charged {
      background: var(--color-orange);
    }

    .items {
      border-radius: 48px;
      background: var(--light-gray);
      text-align: center;
    }

    .items.vertical {
      width: 96px;
      height: 256px;
    }

    .vertical > .itemSlot {
      margin: 16px;
    }

    .itemSlot {
      position: static;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: var(--bg-darker);
    }

    .filled {
      background: transparent;
    }

    .itemSlot > .item {
      width: 100%;
    }

    .item {
      border-radius: 50%;
    }

    #resetStats {
      color: var(--light-red);
      cursor: pointer;
    }

    #resetStats:active {
      filter: brightness(75%);
    }

    #joinMatch, #createMatch {
      width: 450px;
      height: 300px;
      padding: 32px;
      border: 1px solid var(--light-green);
      text-align: center;
    }

    #matchOver > * {
      position: static;
    }

    #fighterOptions {
      background : var(--bg-darker);
      border: solid 1px;
      left: 5%;
      width: 90%;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(4, 450px);
      grid-template-rows: repeat(2, 280px);
      gap: 32px;
      overflow: auto;
    }

    #redFighter {
      grid-column: 1;
      grid-row: 1;
    }

    #yellowFighter {
      grid-column: 1;
      grid-row: 2;
    }

    #greenFighter {
      grid-column: 2;
      grid-row: 1;
    }

    #blueFighter {
      grid-column: 2;
      grid-row: 2;
    }

    #orangeFighter {
      grid-column: 3;
      grid-row: 1;
    }

    #magentaFighter {
      grid-column: 3;
      grid-row: 2;
    }

    #grayFighter {
      grid-column: 4;
      grid-row: 1;
    }

    #goldFighter {
      grid-column: 4;
      grid-row: 2;
    }

    .locked {
      background: var(--bg-dark);
      color: var(--light-gray);
    }

    .lockedIcon {
      width: 128px;
    }

    #chooseItemsCenter {
      left: 0;
      width: 100%;
      text-align: center;
    }

    #chooseItemsCenter > * {
      position: static;
    }

    #chooseItemsCenter > .item {
      width: 96px;
    }

    .itemNameAndImage {
      position: static;
      width: 150px;
      display: inline-block;
    }

    #myItems {
      bottom: 128px;
      width: 256px;
      height: 96px;
    }

    #myItems > .itemSlot {
      display: inline-block;
      margin: 16px 8px;
    }

    .removable:hover {
      filter: brightness(25%);
      cursor: pointer;
    }

    #gameContainer {
      top: 0;
      left: 0;
      width: 80%;
      height: 100%;
      padding: 8px;
      overflow: auto;
    }

    #game {
      top: 0;
      left: 0;
      width: 100%;
      min-width: 1200px;
      height: 100%;
      min-height: 900px;
      padding: 8px;
    }

    #timer {
      font-size: 48px;
    }

    .draggable {
      cursor: grab;
    }

    .draggable:hover {
      filter: brightness(80%);
    }

    .draggable:active {
      cursor: grabbing;
    }

    .playerEffects {
      position: static;
      height: 27px;
    }

    .playerEffects > .effect {
      border-color: white;
    }

    #p1-fastTimer, #p2-fastTimer {
      color: var(--bg-dark);
    }

    #fighter1a, #fighter2a, #fighter1b, #fighter2b {
      position: relative;
    }

    #fighter1a, #fighter2a {
      margin: 8px 0 16px;
    }

    #fighter1b, #fighter2b {
      margin-bottom: 8px;
    }

    .attack {
      animation: attack 0.4s linear;
    }

    @keyframes attack {
      0% {
        transform: translate(0);
      }
      50% {
        transform: translate(var(--attack-x), var(--attack-y));
      }
      100% {
        transform: translate(0);
      }
    }

    .otherOption {
      position: static;
      display: inline-block;
      padding: 2px 4px;
      border-radius: 2px;
      color: white;
      border: 1px solid transparent;
    }

    .otherOption.enabled {
      cursor: pointer;
    }

    .otherOption.enabled:hover {
      background: var(--bg-dark-highlight);
    }

    #instructions {
      bottom: 16px;
      color: var(--light-red);
    }

    .blink {
      animation: blink steps(2, jump-none) 1s infinite;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    .droppable > * {
      pointer-events: none; /*Prevents a bug that causes flickering when dragging over child elements*/
    }

    .defeated {
      transition: all 1s, font-weight 0s;
      background: var(--bg-darker);
      color: var(--color-red);
      padding: 0;
      line-height: 325px;
      text-align: center;
      font-size: 64px;
      font-weight: bold;
    }

    #gameChat {
      top: 0;
      right: 0;
      width: 20%;
      height: 100%;
      border: none;
      border-left: 1px solid;
    }

    .on {
      background: var(--light-green);
      color: var(--bg-dark);
      cursor: default;
    }

    #quickmenu {
      display: none;
    }

    #content {
      /*Paste this to make a full-screen page*/
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      max-width: 100%; /*For some reason, this only works if max-width is present*/
      height: 100%;
      box-sizing: border-box;
      border-radius: 0;
      background-color: transparent;
    }
  </style>
{% endblock %}

<!-- Extra javascript here -->
{% block script %}{% endblock %}

<!-- Main content here -->
{% block main %}
  <div id="border" class="fullScreen">
    <div id="topLeftBorder"></div>
    <div id="topRightBorder"></div>
    <div id="bottomLeftBorder"></div>
    <div id="bottomRightBorder"></div>
  </div>

  <div id="home" class="fullScreen">
    <div style="top: 16px; left: 16px;">
      <h2 id="myName"></h2>
      Total wins: <span id="myWins"></span><br>
      Win percentage: <span id="myPercent"></span><br>
      Win streak: <span id="myStreak"></span><br>
      <u id="resetStats" onclick="resetStats();">Reset stats</u>
    </div>

    <h1 id="title" class="hCentered" style="top: 128px;">Turn-based fighter</h1>

    <div id="joinMatch" class="vCentered" style="left: calc(50% - 482px);">
      <h2>Join match</h2>
      <input type="text" id="joinCode" class="hCentered vCentered" placeholder="Six-digit code" maxlength="6" autocomplete="off"></input>
      <button id="joinButton" class="hCentered unselectable" style="bottom: 32px;">Go</button>
    </div>

    <div id="createMatch" class="vCentered" style="right: calc(50% - 482px);">
      <h2>Create match</h2>
      <div class="hCentered vCentered"><input type="checkbox" id="chatCheckbox" checked><label for="chatCheckbox">Send a link in the chat</label></div>
      <button class="hCentered" style="bottom: 32px;" onclick="createMatch();">Go</button>
    </div>
  </div>

  <div id="chooseFighters" class="fullScreen hidden">
    <div class="large hCentered" style="top: 16px;">
      Choose two fighters to take into the match.<br>
      <button id="randomButton" onclick="randomFighters()"><img src="{{ url_for('static', filename='img/fighter/random.png') }}" class="randomIcon"> Random</button>
    </div>
    <div id="fighterOptions" class="vCentered">
      <div id="redFighter"></div>
      <div id="yellowFighter"></div>
      <div id="greenFighter"></div>
      <div id="blueFighter"></div>
      <div id="orangeFighter"></div>
      <div id="magentaFighter"></div>
      <div id="grayFighter"></div>
      <div id="goldFighter"></div>
    </div>
    <button id="fightersDone" class="hCentered unselectable" style="bottom: 32px;">Done</button>
  </div>

  <div id="chooseItems" class="fullScreen hidden">
    <div class="large hCentered" style="top: 192px; width: 100%;">Choose up to three items to take into the match. You can pick the same item more than once.</div>
    <div id="chooseItemsCenter" class="vCentered">
      <div id="itemOptions"></div><br>
      <div id="itemDesc" style="height: 21px;"></div>
    </div>

    <div id="myItems" class="items hCentered">
      <div id="myItemSlot0" class="itemSlot" onclick="removeItem(0);"><img src="{{ url_for('static', filename='img/fighter/questionMark.png') }}" id="myItem0" class="item" draggable="false"></div
      ><div id="myItemSlot1" class="itemSlot" onclick="removeItem(1);"><img src="{{ url_for('static', filename='img/fighter/questionMark.png') }}" id="myItem1" class="item" draggable="false"></div
      ><div id="myItemSlot2" class="itemSlot" onclick="removeItem(2);"><img src="{{ url_for('static', filename='img/fighter/questionMark.png') }}" id="myItem2" class="item" draggable="false"></div>
    </div>

    <button id="itemsDone" class="hCentered" style="bottom: 32px;">Done</button>
  </div>

  <div id="waiting" class="fullScreen hidden">
    <div class="hCentered" style="top: 64px;">
      <h1 id="opponentStatus" style="position: static;">Waiting for opponent…</h1>
      <h2 style="font-weight: normal;">Your match code is <b id="matchCode"></b></h2>
    </div>
    <iframe width="560" height="315" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen id="video" class="hCentered vCentered"></iframe>
    <div id="tip" class="large hCentered" style="bottom: 32px;"></div>
  </div>

  <div id="gameContainer" class="hidden">
    <div id="game">
      <div>
        <h2 id="p1-name"></h2>
        Total wins: <span id="p1-wins"></span><br>
        Win percentage: <span id="p1-percent"></span><br>
        Win streak: <span id="p1-streak"></span>
      </div>

      <div class="hCentered">
        <h2 id="turn"></h2>
        <span id="timer"></span>
      </div>

      <div style="top: 8px; right: 8px; text-align: right;">
        <h2 id="p2-name"></h2>
        Total wins: <span id="p2-wins"></span><br>
        Win percentage: <span id="p2-percent"></span><br>
        Win streak: <span id="p2-streak"></span>
      </div>

      <div id="p1-items" class="items vertical vCentered" style="left: 32px;">
        <div id="p1-itemSlot0" class="itemSlot filled"><img id="p1-item0" class="item" draggable="false"></div>
        <div id="p1-itemSlot1" class="itemSlot filled"><img id="p1-item1" class="item" draggable="false"></div>
        <div id="p1-itemSlot2" class="itemSlot filled"><img id="p1-item2" class="item" draggable="false"></div>
      </div>

      <div class="vCentered" style="left: 160px;">
        <div id="p1-effects" class="playerEffects"></div>
        <div id="fighter1a"></div>
        <div id="fighter1b"></div>
        <div id="p1-doNothing" class="otherOption">Do nothing</div> | <div id="p1-giveUp" class="otherOption">Give up</div>
      </div>

      <div class="vCentered" style="right: 160px;">
        <div id="p2-effects" class="playerEffects"></div>
        <div id="fighter2a"></div>
        <div id="fighter2b"></div>
        <div style="position: static; text-align: right;">
          <div id="p2-doNothing" class="otherOption">Do nothing</div> | <div id="p2-giveUp" class="otherOption">Give up</div>
        </div>
      </div>

      <div id="p2-items" class="items vertical vCentered" style="right: 32px;">
        <div id="p2-itemSlot0" class="itemSlot filled"><img id="p2-item0" class="item" draggable="false"></div>
        <div id="p2-itemSlot1" class="itemSlot filled"><img id="p2-item1" class="item" draggable="false"></div>
        <div id="p2-itemSlot2" class="itemSlot filled"><img id="p2-item2" class="item" draggable="false"></div>
      </div>

      <div id="instructions" class="large hCentered"></div>
    </div>
  </div>

  <iframe id="gameChat" class="hidden"></iframe>

  <div id="matchOver" class="vCentered hidden" style="left: 0; width: calc(100% - 452px); text-align: center;">
    <h1 id="result"></h1><br>
    <button id="rematchButton" onclick="rematchButton();">Rematch?</button>
    <button style="margin-left: 16px; color: white;" onclick="window.location = '/fighter';">Home</button>
  </div>

  <script>
    let red = {
      color: "red",
      effective: "yellow",
      weak: "blue",
      moves: {
        main: {
          damage: 14,
          doubleTarget: true,
          description: "Deals [damage] damage to both opponent fighters."
        },
        special: {
          charge: 1,
          minDamage: 45,
          maxDamage: 65,
          description: "Deals at least [minDamage] and up to [maxDamage] damage."
        },
        other: {
          type: "revenge",
          revengeDuration: 2,
          selfTarget: true,
          description: "Opponents will take 50% of the damage they inflict on this fighter. Lasts for 2 turns."
        }
      }
    };

    let yellow = {
      color: "yellow",
      effective: "green",
      weak: "red",
      moves: {
        main: {
          damage: 20,
          critDamage: 40,
          critChance: 10,
          description: "Deals [damage] damage. 10% chance of a critical hit, which deals [critDamage] damage."
        },
        alt: {
          damage: 7,
          doubleTarget: true,
          healing: true,
          description: "Deals [damage] damage to both opponent fighters. Dealt damage is added to this fighter's HP."
        },
        other: {
          type: "sacrifice",
          selfTarget: true,
          description: "Sacrifice this fighter. Teammate's attack power increases by 1% for each remaining HP."
        }
      }
    };

    let green = {
      color: "green",
      effective: "blue",
      weak: "yellow",
      moves: {
        main: {
          damage: 24,
          description: "Deals [damage] damage."
        },
        alt: {
          damage: 21,
          stunChance: 25,
          stunDuration: 1,
          description: "Deals [damage] damage. 25% chance of stunning target for 1 turn."
        },
        special: {
          charge: 2,
          damage: 78,
          description: "Deals [damage] damage."
        }
      }
    };

    let blue = {
      color: "blue",
      effective: "red",
      weak: "green",
      moves: {
        main: {
          damage: 16,
          poisonChance: 100,
          poisonDuration: 3,
          description: "Deals [damage] damage, then 5 damage per turn for the next 3 turns."
        },
        special: {
          charge: 1,
          damage: 50,
          secondaryTarget: true,
          secondaryDamage: 15,
          combinedDamage: 60,
          description: "Deals [damage] damage to target and [secondaryDamage] to other fighter. If one opponent fighter is already defeated, deals [combinedDamage] damage."
        },
        other: {
          disorientChance: 100,
          disorientDuration: 2,
          description: "Target's attacks have a 40% chance of missing. Lasts for 2 turns."
        }
      }
    };

    let orange = {
      unlockWins: 3,
      color: "orange",
      effective: "magenta",
      weak: "gold",
      moves: {
        main: {
          damage: 23,
          ignoreShield: true,
          ignoreRevenge: true,
          description: "Deals [damage] damage. Ignores \"shield\" and \"revenge\" effects."
        },
        special: {
          charge: 1,
          damage: 59,
          autoTarget: true,
          description: "Deals [damage] damage to the opponent fighter with the most HP."
        },
        other: {
          type: "addItem",
          selfTarget: true,
          description: "Adds 1 item to your inventory. You can hold up to 3 items at a time."
        }
      }
    };

    let magenta = {
      unlockWins: 8,
      color: "magenta",
      effective: "gray",
      weak: "orange",
      moves: {
        main: {
          damage: 18,
          poisonChance: 45,
          poisonDuration: 3,
          disorientChance: 30,
          disorientDuration: 2,
          stunChance: 15,
          stunDuration: 1,
          description: "Deals [damage] damage. 45% chance of poisoning target for 3 turns, 30% chance of disorienting target for 2 turns, and 15% chance of stunning target for 1 turn."
        },
        alt: {
          damage: 25,
          description: "Deals [damage] damage."
        },
        other: {
          type: "revive",
          selfTarget: true,
          description: "Revives a defeated teammate with 1 HP. Can only be used once."
        },
      }
    };

    let gray = {
      unlockWins: 15,
      color: "gray",
      effective: "gold",
      weak: "magenta",
      moves: {
        main: {
          minDamage: 10,
          maxDamage: 50,
          description: "Deals at least [minDamage] and up to [maxDamage] damage."
        },
        alt: {
          damage: 19,
          doubleTarget: true,
          teamDamage: 6,
          description: "Deals [damage] damage to each opponent fighter and [teamDamage] damage to each fighter on your own team."
        },
        special: {
          charge: 3,
          damage: 91,
          stunChance: 100,
          stunDuration: 2,
          description: "Deals [damage] damage and stuns the target for 2 turns."
        },
      }
    };

    let gold = {
      unlockStreak: 5,
      color: "gold",
      effective: "orange",
      weak: "gray",
      moves: {
        main: {
          damage: 21,
          critDamage: 63,
          critChance: 4,
          description: "Deals [damage] damage. 4% chance of a critical hit, which deals [critDamage] damage."
        },
        alt: {
          type: "copyMove",
          doubleTarget: true,
          description: "Use any of your opponent fighters' moves."
        },
        other: {
          type: "effectRevenge",
          effectRevengeDuration: 3,
          selfTarget: true,
          description: "Opponents will gain any negative effects they give to you or your teammate. Lasts for 3 turns."
        },
      }
    };

    let items = {
      heal: {
        name: "heal",
        description: "Increases one fighter\'s HP by 30."
      },
      attackBoost: {
        name: "attack boost",
        description: "One fighter deals 50% more damage for 3 turns.",
        duration: 3
      },
      fastTimer: {
        name: "fast timer",
        description: "Speeds up opponent\'s timer for 3 turns.",
        duration: 3
      },
      skipTurn: {
        name: "skip turn",
        description: "Opponent can\'t do anything for 1 turn.",
        duration: 1
      },
      shield: {
        name: "shield",
        description: "One fighter takes 50% less damage from attacks for 3 turns.",
        duration: 3
      },
      noItems: {
        name: "no items",
        description: "Opponent can\'t use any items for 2 turns.",
        duration: 2
      },
      cleanse: {
        name: "cleanse",
        description: "Removes all negative effects from you and your fighters."
      }
    };

    let effects = {
      fastTimer: {
        name: "Fast timer",
        type: "player",
        description: "Your time will run out more quickly.",
        color: "yellow"
      },
      skipTurn: {
        name: "Skip turn",
        type: "player",
        description: "Your next turn will be skipped.",
        color: "green"
      },
      noItems: {
        name: "No items",
        type: "player",
        description: "You can't use any items.",
        color: "blue"
      },
      attackBoost: {
        name: "Attack boost",
        type: "fighter",
        description: "Attack power raised by 50%.",
        color: "orange"
      },
      shield: {
        name: "Shield",
        type: "fighter",
        description: "Reduces damage taken from attacks by 50%.",
        color: "cyan"
      },
      revenge: {
        name: "Revenge",
        type: "fighter",
        description: "Opponents will take 50% of the damage they inflict on this fighter.",
        color: "red"
      },
      effectRevenge: {
        name: "Effect revenge",
        type: "fighter",
        description: "Opponents will gain any negative effects they give to this fighter.",
        color: "gold"
      },
      poison: {
        name: "Poison",
        type: "fighter",
        description: "Take 5 damage per turn.",
        color: "purple"
      },
      disoriented: {
        name: "Disoriented",
        type: "fighter",
        description: "Attacks have a 40% chance of missing.",
        color: "pink"
      },
      stunned: {
        name: "Stunned",
        type: "fighter",
        description: "Can't use this fighter.",
        color: "brown"
      }
    };

    let fighter1a = {
      team: 1,
      name: "1a",
    };

    let fighter1b = {
      team: 1,
      name: "1b",
    };

    let fighter2a = {
      team: 2,
      name: "2a",
    };

    let fighter2b = {
      team: 2,
      name: "2b",
    };

    let me = {
      name: "{{ username }}",
      defeated: [],
      colors: [],
      items: [],
      effects: {},
      //Convert from strings to numbers; set to 0 if undefined
      wins: +localStorage.getItem("fighterWins") || 0,
      losses: +localStorage.getItem("fighterLosses") || 0,
      winStreak: +localStorage.getItem("fighterWinStreak") || 0,
    };

    let colors = [red, yellow, green, blue];
    let lockedColors = [orange, magenta, gray, gold];
    let fighters = [];
    let defeated = [];
    let damageProperties = ["damage", "minDamage", "maxDamage", "critDamage", "secondaryDamage", "combinedDamage", "teamDamage"];


    let match;
    let matchCode;
    let itemsArr = [];
    let opponent = {};
    let player1;
    let player2;
    let players = [];
    let active;
    let inactive;
    let countdown;
    let time;
    let winnerOverride;
    let matchOver;

    let urlParams = new URLSearchParams(window.location.search);
    let joinCode = urlParams.get("match");
    let rematchCode = urlParams.get("rematch");
    if (joinCode) joinMatch(joinCode);
    else if (rematchCode) rematch();
    else {
      document.getElementById("myName").innerText = me.name;
      updateStats();
      document.getElementById("joinCode").onkeydown = function() {if (event.keyCode == 13) joinMatch(this.value);}; //Execute joinMatch() when enter key pressed
    }

    function capitalize(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function pickRandom(max) {
      return Math.floor(Math.random() * max);
    }

    function getTeammate(fighter) {
      if (player1.fighters.includes(fighter)) player = player1;
      else player = player2;
      let teammate = player.fighters.filter(playerFighter => playerFighter != fighter); //Get array of player's fighters and remove one
      return teammate[0]; //Return only item of new array
    }

    function sendPlayerReady() {
      let sendObj = {
        type: "fighter",
        to: opponent.name,
        from: me.name,
        content: {
          type: "player",
          player: me
        },
      }
      ws.send(JSON.stringify(sendObj));
    }

    function sendMessage(content, recipient = opponent.name) {
      /*//for testing
      console.log(content); ///et*/
      let messageObj = {
        type: "message",
        to: recipient,
        from: "server",
        content: content
      };
      ////ws.send(JSON.stringify(messageObj));
      if (!recipient != "all") { //If message is private, send to sender in addition to recipient
        messageObj.to = me.name;
        ////ws.send(JSON.stringify(messageObj));
      }
    }

    function sendMove(moveObj) {
      let sendObj = {
        type: "fighter",
        to: opponent.name,
        from: me.name,
        content: {
          match: matchCode,
          type: "move",
          move: moveObj
        }
      };
      console.log("sm");
      console.log(sendObj);
      ws.send(JSON.stringify(sendObj));

      /*//for testing
      receiveMove(moveObj); ///et*/
    }

    ws.onmessage = message => {
      let data = JSON.parse(message.data);
      console.log(data);
      if (data.type == "fighter") {
        if (data.content.type == "join" && data.from != me.name) document.getElementById("opponentStatus").innerText = "Opponent is getting ready…";
        if (data.content.type == "player" && data.from != me.name) receivePlayerReady(data.content.player);
        else if (data.content.match == matchCode) { //Only receive if sent from current match
          console.log(data.content.type);
          if (data.content.type == "move") receiveMove(data.content.move);
          else if (data.content.type == "item") receiveItem(data.content);
          else if (data.content.type == "rematch" && players.every(player => player.rematch) && me.team == 1) window.location = "/fighter?rematch=" + matchCode;
        }
      }
    };

    document.getElementById("joinCode").oninput = function() {
      for (let char of this.value) if (/\D/.test(char)) this.value = this.value.replace(char, ""); //Only allow numbers
      if (this.value.length == 6) {
        document.getElementById("joinButton").classList.remove("unselectable");
        document.getElementById("joinButton").onclick = () => joinMatch(document.getElementById('joinCode').value);
      } else {
        document.getElementById("joinButton").classList.add("unselectable");
        document.getElementById("joinButton").onclick = null;
      }
    };


    function updateStats() {
      if (opponent.name) { //Do this if in a match
        let p1Percent = Math.round(player1.wins / (player1.wins + player1.losses) * 100);
        p1Percent = (p1Percent || 0) + "%"; //If NaN, set to 0
        let p2Percent = Math.round(player2.wins / (player2.wins + player2.losses) * 100);
        p2Percent = (p2Percent || 0) + "%";
        document.getElementById("p1-wins").innerText = player1.wins;
        document.getElementById("p1-percent").innerText = p1Percent;
        document.getElementById("p1-streak").innerText = player1.winStreak;
        document.getElementById("p2-wins").innerText = player2.wins;
        document.getElementById("p2-percent").innerText = p2Percent;
        document.getElementById("p2-streak").innerText = player2.winStreak;
      } else {
        let myPercent = Math.round(me.wins / (me.wins + me.losses) * 100);
        myPercent = (myPercent || 0) + "%";
        document.getElementById("myWins").innerText = me.wins;
        document.getElementById("myPercent").innerText = myPercent;
        document.getElementById("myStreak").innerText = me.winStreak;
      }

      ////save to account instead of local storage
      localStorage.setItem("fighterWins", me.wins);
      localStorage.setItem("fighterLosses", me.losses);
      localStorage.setItem("fighterWinStreak", me.winStreak);
      if (me.winStreak == gold.unlockStreak) localStorage.setItem("goldUnlocked", true);
    }

    function resetStats() {
      if (confirm("Are you sure?")) {
        me.wins = 0;
        me.losses = 0;
        me.winStreak = 0;
        localStorage.setItem("goldUnlocked", "");
        updateStats();
      }
    }

    function joinMatch(code) {
      request.open("GET", '/getfightermatches', false);
      request.send(null);
      let res = JSON.parse(request.responseText);
      match = res["match" + code];
      /*//for testing
      match = {creator: me.name}; ///et*/
      if (!match) {
        alert("Match does not exist.");
      } else if (match.opponent) {
        alert("Match is already full.");
      } else if (match.creator == me.name) {
        alert("You can't join your own match.");
      } else {
        me.team = 2;
        me.fighters = [fighter2a, fighter2b];
        opponent.name = match.creator;
        ws.send(JSON.stringify({
          type: "fighter",
          to: opponent.name,
          from: me.name,
          content: {type: "join"}
        }));
        fighterOptions();
      }
    }

    function rematch() {
      me.team = 1;
      ////get match
      opponent.name = match.creator;
      fighterOptions();
    }

    function createMatch() {
      //Give this match a six-digit ID
      matchCode = pickRandom(1000000).toString();
      while (matchCode.length < 6) matchCode = "0" + matchCode;
      me.team = 1;
      me.fighters = [fighter1a, fighter1b];
      pickRandom(2) ? me.firstMove = true : me.firstMove = false; //Decide which player goes first
      fighterOptions();
    }

    function fighterOptions() {
      document.getElementById("home").classList.add("hidden");
      document.getElementById("chooseFighters").classList.remove("hidden");

      lockedColors.forEach((color) => {
        /*//for testing ///et*/
        if ((color.unlockWins && me.wins >= color.unlockWins)/* || localStorage.getItem(color.color + "Unlocked")*/) { //If player has enough wins to unlock or already unlocked
          colors.push(color);
          lockedColors = lockedColors.filter(locked => locked != color);
        } else {
          let el = document.getElementById(color.color + "Fighter");
          let lockedMessage;
          if (color.unlockWins) lockedMessage = color.unlockWins + " wins to unlock";
          /*//for testing ///et*/
          else if (localStorage.getItem(color.color + "Unlocked")) lockedMessage = "Temporarily disabled<br>due to bugs";
          else lockedMessage = color.unlockStreak + "-win streak to unlock";
          el.classList.add("fighter", "locked");
          el.innerHTML = `<div class="vCentered" style="left: 0; width: 100%; text-align: center;">
            <img src="{{ url_for('static', filename='img/fighter/locked.png') }}" class="lockedIcon"><br><br>
            <h2>${lockedMessage}</h2>
          </div>`;
        }
      });

      colors.forEach(color => {
        let el = document.getElementById(color.color + "Fighter");
        color.hp = 100;
        createFighter(color, el);
        el.classList.add("targetOption");
        el.onclick = () => {chooseFighter(color);};
      });
    }

    function createFighter(fighter, fighterEl) {
      let fighterId;
      let fighterEffects = "";
      if (colors.includes(fighter)) fighterId = fighter.color;
      else fighterId = fighter.name;
      fighterEl.classList.add("fighter", fighter.color);
      fighter.attackFactor = 1;
      fighter.effects = {};
      for (let effect in effects) {
        let effectObj = effects[effect];
        if (effectObj.type == "fighter") fighterEffects += `<div id="${fighterId}-${effect}" class="effect hidden" style="background: var(--color-${effectObj.color})">${effectObj.name}</div> `;
      }
      fighterEl.innerHTML = `<h3 id="${fighterId}-name">${capitalize(fighter.color)}</h3>
      <div class="fighterEffects">
        ${fighterEffects}
        <div id="${fighterId}-allEffects" class="effect hidden" style="background: var(--dark-gray)">2</div>
      </div>
      Effective against ${fighter.effective}, weak against ${fighter.weak}
      <div id="${fighterId}-HPBar" class="HPBar"></div><span id="${fighterId}-HPNum">${fighter.hp}</span> HP <span id="${fighterId}-HPNumChange" style="opacity: 0;"></span><br>`;
      fillHPBar(fighter, document.getElementById(fighterId + "-HPBar"));
      for (let move in fighter.moves) {
        let moveObj = fighter.moves[move];
        let moveCharge = "";
        let description = moveObj.description;
        if (move == "other") moveObj.name = move + " move";
        else moveObj.name = move + " attack";
        moveObj.id = move;
        moveObj.charged = 0;
        if (moveObj.charge) {
          if (moveObj.charge == 1) moveCharge = "<b>Charge:</b> 1 turn ";
          else moveCharge = `<b>Charge:</b> ${moveObj.charge} turns `;
          for (let i = 0; i < moveObj.charge; i++) moveCharge += `<div id="${fighterId}-${move}-cs${i + 1}" class="chargeSquare"></div>`;
          moveCharge += "<br>";
        }
        damageProperties.forEach(property => description = description.replace("[" + property + "]", `<span id=${fighterId}-${move}-${property}>${moveObj[property]}</span>`)); //Replace placeholders
        fighterEl.innerHTML += `<div id="${fighterId}-${move}" class="move">
          <h4>${capitalize(moveObj.name)}</h4>
          <span id="${fighterId}-${move}-charge">${moveCharge}</span>
          ${description}
        </div>`;
      }
      if (!colors.includes(fighter)) {
        for (let move in fighter.moves) { //This only works if it's in a separate for loop
          let moveObj = fighter.moves[move];
          moveObj.el = document.getElementById(fighter.name + "-" + move);
        }
      }
    }

    function fillHPBar(fighter, el) {
      let barColor = "green";
      if (fighter.hp < 10) barColor = "red";
      else if (fighter.hp < 25) barColor = "orange";
      else if (fighter.hp < 50) barColor = "yellow";
      el.style.background = `linear-gradient(to left, var(--color-${barColor}) 0 ${fighter.hp}%, var(--bg-dark) ${fighter.hp}% 100%)`;
    }

    function randomFighters() {
      colors.forEach(color => unchooseFighter(color));
      while (me.colors.length < 2) {
        let random = pickRandom(colors.length);
        chooseFighter(colors[random]);
      }
    }

    function chooseFighter(color) {
      let chosenEl = document.getElementById(color.color + "Fighter");
      chosenEl.style.filter = "drop-shadow(0 0 6px white)";
      me.colors.push(color);
      me.colors = colors.filter(color => me.colors.includes(color)); //Removes duplicates and puts in correct order
      chosenEl.onclick = () => unchooseFighter(color);

      if (me.colors.length == 2) {
        let buttonEl = document.getElementById("fightersDone");
        //Make all fighters unselectable
        colors.forEach(fighter => {
          let fighterEl = document.getElementById(fighter.color + "Fighter");
          if (!me.colors.includes(fighter)) {
            fighterEl.classList.remove("targetOption");
            fighterEl.classList.add("unselectable");
            fighterEl.onclick = null;
          }
        });
        buttonEl.classList.remove("unselectable");
        buttonEl.onclick = () => itemOptions();
      }
    }

    function unchooseFighter(color) {
      let chosenEl = document.getElementById(color.color + "Fighter");
      chosenEl.style.filter = null;
      me.colors.splice(me.colors.indexOf(color), 1);

      //Make all fighters selectable
      colors.forEach(fighter => {
        let fighterEl = document.getElementById(fighter.color + "Fighter");
        fighterEl.classList.remove("unselectable");
        fighterEl.classList.add("targetOption");
        if (!me.colors.includes(fighter)) fighterEl.onclick = () => chooseFighter(fighter);
      });

      let buttonEl = document.getElementById("fightersDone");
      buttonEl.classList.add("unselectable");
      buttonEl.onclick = null;
    }

    function itemOptions() {
      document.getElementById("chooseFighters").classList.add("hidden");
      document.getElementById("chooseItems").classList.remove("hidden");
      document.getElementById("itemsDone").onclick = () => itemsDone();

      for (let item in items) itemsArr.push(item);
      itemsArr.forEach(item => {
        let itemObj = items[item];
        document.getElementById("itemOptions").innerHTML +=
        `<div class="itemNameAndImage">
          <h3>${capitalize(itemObj.name)}</h3><br>
          <img id="${item}" class="item targetOption" src="/static/img/fighter/${item}.png" draggable="false">
        </div>`;
      });
      itemsArr.forEach(item => {
        let el = document.getElementById(item);
        el.onmouseover = () => document.getElementById("itemDesc").innerText = items[item].description;
        el.onmouseout = () => document.getElementById("itemDesc").innerText = null;
        el.onclick = () => chooseItem(item);
      });
    }

    function chooseItem(item) {
      me.items.push(item);
      displayChosenItems();
      if (me.items.length == 3) itemsArr.forEach((item) => { //Make all items unselectable
        let optionEl = document.getElementById(item);
        document.getElementById("itemDesc").innerText = null;
        optionEl.classList.remove("targetOption");
        optionEl.classList.add("unselectable");
        optionEl.onmouseover = null;
        optionEl.onclick = null;
      });
    }

    function removeItem(slot) {
      me.items.splice(slot, 1);
      displayChosenItems();
      //Make all items selectable
      itemsArr.forEach((item) => {
        let itemObj = items[item];
        let optionEl = document.getElementById(item);
        optionEl.classList.remove("unselectable");
        optionEl.classList.add("targetOption");
        optionEl.onmouseover = () => document.getElementById("itemDesc").innerText = itemObj.description;
        optionEl.onclick = () => chooseItem(item);
      });
    }

    function displayChosenItems() {
      for (let i = 0; i < 3; i++) {
        let slotEl = document.getElementById("myItemSlot" + i);
        let imgEl = document.getElementById("myItem" + i);
        if (me.items[i]) {
          imgEl.src = "/static/img/fighter/" + me.items[i] + ".png";
          imgEl.classList.add("removable");
          imgEl.title = "Remove";
          slotEl.classList.add("filled");
        } else {
          imgEl.src = "{{ url_for('static', filename='img/fighter/questionMark.png') }}";
          imgEl.classList.remove("removable");
          imgEl.removeAttribute("title");
          slotEl.classList.remove("filled");
        }
      }
    }

    function itemsDone() {
      document.getElementById("chooseItems").classList.add("hidden");

      me.fighters.forEach((fighter, i) => {
        let color = me.colors[i];
        //Copy all properties from color object to fighter object
        for (let property in color) {
          if (typeof color[property] == "object") fighter[property] = JSON.parse(JSON.stringify(color[property])); //Perform a "deep copy" so object can be modified without changing original
          else fighter[property] = color[property];
        }
      });

      /*//for testing
      let of1 = colors[pickRandom(7)];
      let of2;
      do {of2 = colors[pickRandom(7)]} while (of2 == of1);
      for (let property in of1) {
        if (typeof of1[property] == "object") fighter2a[property] = JSON.parse(JSON.stringify(of1[property])); //Perform a "deep copy" so object can be modified without changing original
        else fighter2a[property] = of1[property];
      }
      for (let property in of2) {
        if (typeof of2[property] == "object") fighter2b[property] = JSON.parse(JSON.stringify(of2[property])); //Perform a "deep copy" so object can be modified without changing original
        else fighter2b[property] = of2[property];
      }
      ///et*/

      while (me.items.length < 3) {
        let random = pickRandom(itemsArr.length);
        me.items.push(itemsArr[random]);
      }

      if (me.team == 1) wait();
      else if (match.opponent) {
        alert("Match is already full.");
        window.location = "/fighter";
      }
      else sendPlayerReady();
    }

    function wait() {
      document.getElementById("waiting").classList.remove("hidden");

      document.getElementById("matchCode").innerText = matchCode;

      if (document.getElementById("chatCheckbox").checked) {
        let message = `${me.name} is looking for a Fighter opponent.<br>
        <button onclick="window.location = '/fighter?match=${matchCode}';">Join match</button>`;
        sendMessage(message, "all");
      }

      if (rematchCode) sendPlayerReady();

      request.open("GET", "/createfightermatch?code=" + matchCode + "&name=" + me.name);
      request.send();

      let tips = [
        "While in a match, look at the bottom of the screen for instructions.",
        "Pay attention to the game chat; it contains useful information.",
        "Using an item won't end your turn.",
        "You can't use items while charging an attack.",
        "You can hover over items and effects for more information.",
        "You will receive a loss if you leave an ongoing match.",
        //"In 2v2 mode, items are selected randomly and can be used by either teammate.",
        //"In 2v2 mode, the \"cleanse\" item affects both you and your teammate."
      ];

      let randomTip = pickRandom(tips.length);
      document.getElementById("tip").innerText = tips[randomTip];
      ////!let randomVideo = pickRandom(videos.length);
      ////document.getElementById("video").src = "https://www.youtube.com/embed/" + videos[randomVideo] + "?autoplay=1&fs=0&modestbranding=1";
      ////if (true) document.getElementById("video").src += "&cc_load_policy=1&mute=1";

      /*//for testing
      receivePlayerReady({
        name: "Player 2",
        team: 2,
        fighters: [fighter2a, fighter2b],
        defeated: [],
        items: ["heal", "attackBoost", "fastTimer"],
        effects: {},
        wins: 0,
        losses: 0,
        winStreak: 0,
      });
      ///et*/
    }

    function receivePlayerReady(player) {
      opponent = player;
      if (me.team == 1) {
        fighter2a = opponent.fighters[0];
        fighter2b = opponent.fighters[1];
        request.open("GET", "/addfighteropponent?code=" + matchCode + "&name=" + player.name);
        request.send();
        sendPlayerReady();
      } else {
        fighter1a = opponent.fighters[0];
        fighter1b = opponent.fighters[1];
        matchCode = player.match;
        opponent.firstMove ? me.firstMove = false : me.firstMove = true;
      }
      fighters = [fighter1a, fighter1b, fighter2a, fighter2b];
      fighters.forEach(fighter => fighter.el = document.getElementById("fighter" + fighter.name));

      ////!get ready at same time
      if (me.rematch) window.location = "/fighter?match=" + matchCode; //Join match if you are player 2 and waiting for rematch
      startMatch();
    }

    function startMatch() {
      document.getElementById("waiting").classList.add("hidden");
      document.getElementById("border").classList.add("hidden");
      document.getElementById("gameContainer").classList.remove("hidden");
      document.getElementById("gameChat").classList.remove("hidden");

      if (me.team == 1) {
        player1 = me;
        player2 = opponent;
      } else {
        player1 = opponent;
        player2 = me;
      }

      updateStats();

      ////save to account instead?
      //Add a loss and reset win streak in case player leaves during match
      localStorage.setItem("fighterLosses", me.losses + 1);
      localStorage.setItem("fighterWinStreak", 0);

      players = [player1, player2];

      document.getElementById("p1-name").innerText = player1.name;
      document.getElementById("p2-name").innerText = player2.name;

      //Create player effect elements
      for (let effect in effects) {
        let effectObj = effects[effect];
        if (effectObj.type == "player") {
          document.getElementById("p1-effects").innerHTML += `<div id="p1-${effect}" class="effect hidden" style="background: var(--color-${effectObj.color})">${effectObj.name}</div> `;
          document.getElementById("p2-effects").innerHTML += `<div id="p2-${effect}" class="effect hidden" style="background: var(--color-${effectObj.color})">${effectObj.name}</div> `;
        }
      }

      fighters.forEach(fighter => {
        createFighter(fighter, fighter.el);
        for (let move in fighter.moves) {
          let moveObj = fighter.moves[move];
          if (moveObj.type == "addItem" || moveObj.type == "revive") unselectable(moveObj);
        }
      });

      //Add item images and give them titles
      me.items.forEach((item, i) => {
        let el = document.getElementById("p" + me.team + "-item" + i);
        el.src = "/static/img/fighter/" + item + ".png";
        el.title = items[item].description;
      });

      opponent.items.forEach((item, i) => {
        let el = document.getElementById("p" + opponent.team + "-item" + i);
        el.src = "/static/img/fighter/" + item + ".png";
        el.title = items[item].description;
      });

      me.firstMove ? active = me : active = opponent;

      let giveUpEl = document.getElementById("p" + me.team + "-giveUp");
      giveUpEl.classList.add("enabled");
      giveUpEl.onclick = () => {
        sendMove({
          move: "give up",
          winner: opponent
        });
        sendMessage(me.name + " forfeited the match.");
      };

      document.getElementById("gameChat").src = "/chat?game=" + opponent.name;

      startTurn();
    }

    function startTurn() {
      if (matchOver) return;

      active == me ? inactive = opponent : inactive = me;

      /*//for testing
      me = active;
      opponent = inactive;
      ///et*/

      let activeNameEl = document.getElementById("p" + active.team + "-name");
      activeNameEl.style.color = "var(--light-red)";
      let inactiveNameEl = document.getElementById("p" + inactive.team + "-name");
      inactiveNameEl.style.color = "white";

      time = 30;
      startTimer();

      opponent.fighters.forEach(fighter => {if (fighter.effects.poison) damage(fighter, 5);}); //Deal poison damage

      //Decrease turns left for effects
      players.forEach(player => {
        for (let effect in player.effects) {
          if (player.effects[effect] == 0.5) removeEffect(effect, player);
          if (player.effects[effect]) {
            let effectEl = document.getElementById("p" + player.team + "-" + effect);
            let effectObj = effects[effect];
            player.effects[effect] -= 0.5;
            effectTitle(effect, player);
          }
        }
      });

      fighters.forEach(fighter => {
        for (let effect in fighter.effects) {
          if (fighter.effects[effect] == 0.5) removeEffect(effect, fighter);
          if (fighter.effects[effect]) {
            let effectEl = document.getElementById(fighter.name + "-" + effect);
            let effectObj = effects[effect];
            fighter.effects[effect] -= 0.5;
            effectTitle(effect, fighter);
          }
        }
      });

      if (active.effects.skipTurn) {
        endTurn();
        return;
      }

      active.fighters.forEach(fighter => {
        for (let move in fighter.moves) {
          if (fighter.moves[move].charged) {
            if (fighter.effects.stunned) endTurn();
            else charge(fighter, fighter.moves[move], fighter.chargeTarget);
            return;
          }
        }
      });

      if (active == me) {
        document.getElementById("turn").innerText = "Your turn";
        enableMoves(me);
        if (me.fighters.every(fighter => fighter.effects.stunned)) {
          if (me.items.some(item => item)) sendMessage("All of " + me.name + "'s available fighters are stunned. You can use the \"Do nothing\" button to skip your turn."); //Don't end turn if player has unused items
          else {
            endTurn();
            return;
          }
        }
        if (me.effects.noItems) {
          let containerEl = document.getElementById("p" + me.team + "-items");
          containerEl.classList.add("unselectable");
        } else {
          let containerEl = document.getElementById("p" + me.team + "-items");
          containerEl.classList.remove("unselectable");
          me.items.forEach((item, i) => { //Enable items
            let itemEl = document.getElementById("p" + me.team + "-item" + i);
            let slotEl = document.getElementById("p" + me.team + "-itemSlot" + i);
            itemEl.classList.remove("unselectable");
            itemEl.draggable = true;
            itemEl.classList.add("draggable");
            itemEl.ondrag = () => pickUpItem(item, i);
            itemEl.ondragend = () => cancelItem(itemEl, slotEl);
          });
        }
        let doNothingEl = document.getElementById("p" + me.team + "-doNothing");
        doNothingEl.classList.add("enabled");
        doNothingEl.onclick = () => {
          sendMove({});
          sendMessage(me.name + " skipped their turn.");
        };
      }
      else document.getElementById("turn").innerText = "Opponent's turn";
    }

    function startTimer() {
      let timerEl = document.getElementById("timer");
      let interval;
      timerEl.innerText = time;
      if (me.effects.fastTimer) {
        timerEl.style.color = "var(--light-yellow)";
        interval = 100;
      } else {
        timerEl.style.color = "white";
        interval = 1000;
      }
      countdown = setInterval(() => {
        timerEl.innerText = --time;
        if (time < 6) timerEl.style.color = "var(--light-red)";
        if (!time) {
          sendMessage(active.name + " ran out of time.");
          endTurn();
        }
      }, interval);
    }

    function effectTitle(effect, target) {
      let effectEl;
      let effectObj = effects[effect];
      let targetEffectObj = target.effects[effect];
      if (effectObj.type == "fighter") effectEl = document.getElementById(target.name + "-" + effect);
      else effectEl = document.getElementById("p" + target.team + "-" + effect);
      if (Math.round(targetEffectObj) == 1) effectEl.title = effectObj.description + " 1 turn left.";
      else effectEl.title = effectObj.description + " " + Math.round(targetEffectObj) + " turns left.";
    }

    function enableMoves(player, copySender, copyMove) {
      console.log("enable");
      player.fighters.forEach(fighter => {
        for (let move in fighter.moves) {
          let moveObj = fighter.moves[move];
          if (fighter.effects.stunned || (moveObj.type == "addItem" && me.items.every(item => item)) || (moveObj.type == "revive" && me.fighters.length == 2) || (moveObj.type == "copyMove" && copySender)) unselectable(moveObj); //If move type is addItem, disable if all items are unused. If move type is revive, disable neither fighter is defeated.
          if (!moveObj.unselectable) {
            let sender = copySender || fighter;
            let clickFunction;
            moveObj.el.classList.add("enabled");
            if (moveObj.doubleTarget || moveObj.selfTarget || moveObj.autoTarget) {
              if (moveObj.charge) clickFunction = () => charge(sender, copyMove || moveObj);
              else clickFunction = () => useMove(sender, copyMove || moveObj);
            }
            else clickFunction = () => selectTarget(sender, copyMove || moveObj);
            if (copySender) moveObj.el.onclick = () => {
              let chargeEl = document.getElementById(sender.name + "-" + copyMove.id + "-charge");
              for (let property in copyMove) if (property != "name" && property != "id" && property != "el") delete copyMove[property]; //Delete all properties of copyMove except "name", "id", and "el"
              for (let property in moveObj) if (property != "name" && property != "id" && property != "el") copyMove[property] = moveObj[property]; //Make copyMove a duplicate of target move
              copyMove.copied = {
                color: fighter.color,
                move: moveObj.name
              };
              ////! do after target selected; can other player see?
              if (copyMove.charge) {
                if (copyMove.charge == 1) chargeEl.innerHTML = "<b>Charge:</b> 1 turn ";
                else chargeEl.innerHTML = `<b>Charge:</b> ${copyMove.charge} turns `;
                for (let i = 0; i < copyMove.charge; i++) chargeEl.innerHTML += `<div id="${sender.name}-${copyMove.id}-cs${i + 1}" class="chargeSquare"></div>`;
                chargeEl.innerHTML += "<br>";
              }
              ////!
              for (let move in opponent.moves) {
                let moveObj = fighter.moves[move];
                moveObj.el.classList.remove("enabled");
                moveObj.el.onclick = null;
              }
              clickFunction();
              ////! click copymove while selecting
              event.stopPropagation();
            }
            else moveObj.el.onclick = () => clickFunction();
          }
        }
      });
    }

    function unselectable(move) {
      move.unselectable = true;
      move.el.classList.add("unselectable");
    }

    function removeUnselectable(move) {
      move.unselectable = false;
      move.el.classList.remove("unselectable");
    }

    function showInstructions(text) {
      let el = document.getElementById("instructions");
      el.innerText = text;
      el.classList.add("blink");
    }

    function hideInstructions() {
      let el = document.getElementById("instructions");
      el.innerText = null;
      el.classList.remove("blink");
    }

    function selectTarget(sender, move) {
      showInstructions("Select target");
      opponent.fighters.forEach(fighter => {
        fighter.el.classList.add("targetOption");
        if (move.charge) fighter.el.onclick = () => charge(sender, move, fighter);
        else fighter.el.onclick = () => useMove(sender, move, fighter);
      });
    }

    function removeTargetOptions() {
      hideInstructions();
      fighters.forEach(fighter => {
        fighter.el.classList.remove("targetOption");
        fighter.el.onclick = null;
      });
    }

    function charge(sender, move, target) {
      if (move.charged == move.charge) { //If move is fully charged
        move.charged = 0;
        sender.chargeTarget = null;
        //Reset all chargeSquares
        for (let i = 1; i <= move.charge; i++) {
          let el = document.getElementById(sender.name + "-" + move.id + "-cs" + i);
          el.classList.remove("charged");
        }
        if (fighters.includes(target) || !target) useMove(sender, move, target);
        else { //If target is defeated
          sendMessage(me.name + " couldn't use " + capitalize(sender.color) + "'s " + move.name + " because the target was already defeated.");
          endTurn();
        }
      } else {
        let el = document.getElementById(sender.name + "-" + move.id + "-cs" + ++move.charged);
        sender.chargeTarget = target;
        el.classList.add("charged");
        sendMessage(me.name + " charged " + capitalize(sender.color) + "'s " + move.name + ".");
        endTurn();
      }
    }

    function useMove(sender, move, targets = opponent.fighters) {
      let primaryTarget;
      let targetTeammate;
      let message = me.name + " used " + capitalize(sender.color) + "'s " + move.name;
      if (move.secondaryTarget) {
        primaryTarget = targets;
        targets = opponent.fighters;
      } else if (move.autoTarget) {
        //Set target to fighter with highest HP; if both fighters have same HP, choose randomly
        if (opponent.fighters.length == 1 || opponent.fighters[0].hp > opponent.fighters[1].hp) targets = opponent.fighters[0];
        else if (opponent.fighters[0].hp == opponent.fighters[1].hp) targets = opponent.fighters[pickRandom(2)];
        else targets = opponent.fighters[1];
      }
      if (!Array.isArray(targets)) targets = [targets]; //If there is only one target, turn it into an array
      if (targets.length == 1) targetTeammate = getTeammate(targets[0]);
      let sendObj = {
        sender: sender,
        targets: targets,
        primaryTarget: primaryTarget,
        senderTeammate: getTeammate(sender),
        targetTeammate: targetTeammate,
        move: move,
        damage: [],
        selfDamage: 0,
        teammateDamage: 0,
        poison: [],
        disorient: [],
        stun: []
      };

      if (sender.effects.disoriented && (pickRandom(100) < 40)) message += " and missed";
      else {
        targets.forEach((target, i) => {
          if (move.secondaryTarget) {
            if (target == primaryTarget) {
              if (fighters.includes(targetTeammate)) sendObj.damage[i] = move.damage;
              else sendObj.damage[i] = move.combinedDamage;
            }
            else sendObj.damage[i] = move.secondaryDamage;
          }
          else if (move.damage) sendObj.damage[i] = move.damage;
          else sendObj.damage[i] = pickRandom(move.maxDamage - move.minDamage + 1) + move.minDamage;

          if (move.critChance && pickRandom(100) < move.critChance) {
            sendObj.damage[i] = move.critDamage;
            message += " and got a critical hit";
          }
          sendObj.damage[i] *= sender.attackFactor;
          if (sender.effective == target.color) sendObj.damage[i] *= 1.25;
          else if (sender.weak == target.color) sendObj.damage[i] *= 0.75;
          if (target.effects.shield && !move.ignoreShield) sendObj.damage[i] /= 2;
          sendObj.damage[i] = Math.round(sendObj.damage[i]);

          if (target.effects.revenge && !move.ignoreRevenge) sendObj.selfDamage += Math.min(sendObj.damage[i], target.hp) / 2; //Check which is lower: move's damage or target's remaining HP, then divide by 2 and set damage to sender
          if (move.healing) sendObj.selfDamage -= sendObj.damage[i];
          if (move.teamDamage) {
            sendObj.selfDamage += move.teamDamage * sender.attackFactor;
            sendObj.teammateDamage += move.teamDamage * sender.attackFactor;
          }
          sendObj.selfDamage = Math.round(sendObj.selfDamage);
          sendObj.teammateDamage = Math.round(sendObj.teammateDamage);

          let messageEffects = [];

          //If random number 0–99 < percent chance of effect, add effect
          if (move.poisonChance && pickRandom(100) < move.poisonChance) {
            sendObj.poison[i] = true;
            if (move.poisonChance < 100) messageEffects.push("poisoned"); //Don't add to message if effect chance is 100 (i.e., the effect is guaranteed)
          }

          if (move.disorientChance && pickRandom(100) < move.disorientChance) {
            sendObj.disorient[i] = true;
            if (move.disorientChance < 100) messageEffects.push("disoriented");
          }

          if (move.stunChance && pickRandom(100) < move.stunChance) {
            sendObj.stun[i] = true;
            if (move.stunChance < 100) messageEffects.push("stunned");
          }

          if (messageEffects.length == 3) message += " and " + messageEffects[0] + ", " + messageEffects[1] + ", and " + messageEffects[2] + " the target";
          else if (messageEffects.length == 2) message += " and " + messageEffects[0] + " and " + messageEffects[1] + " the target";
          else if (messageEffects.length) message += " and " + messageEffects[0] + " the target";
        });
      }

      if (move.type == "addItem") {
        let random = pickRandom(itemsArr.length);
        sendObj.newItem = itemsArr[random];
      }

      if (move.type == "revive") move.used = true;

      if (move.type == "copyMove") {
        enableMoves(opponent, sender, move);
        showInstructions("Select move");
      } else {
        sendMove(sendObj);
        if (move.copied) {
          message += " to copy " + capitalize(move.copied.color) + "'s " + move.copied.move;
          //Reset move to original
          for (let property in move) if (property != "id" && property != "el") delete move[property];
          for (let property in gold.moves[move.id]) move[property] = gold.moves[move.id][property];
          document.getElementById(sender.name + "-" + move.id + "-charge").innerHTML = null;
        }
        sendMessage(message + ".");
      }
    }

    function receiveMove(data) {
      console.log("rm");
      console.log(data);
      if (data.move) {
        if (data.move == "give up") {
          matchOver = true;
          endMatch(data.winner);
        }

        else if (data.move.type == "revenge") addEffect("revenge", data.sender, data.move.revengeDuration);

        else if (data.move.type == "effectRevenge") active.fighters.forEach(fighter => addEffect("effectRevenge", fighter, data.move.effectRevengeDuration));

        else if (data.move.type == "sacrifice") {
          let factor = data.sender.hp / 100 + 1;
          changeAttack(data.senderTeammate, factor);
          defeat(data.sender);
        }

        else if (data.move.type == "addItem") {
          active.items.every((item, i) => {
            if (!item) { //If item already used
              let itemEl = document.getElementById("p" + data.sender.team + "-item" + i);
              let slotEl = document.getElementById("p" + data.sender.team + "-itemSlot" + i);
              active.items[i] = data.newItem;
              itemEl.src = "{{ url_for('static', filename='img/fighter/" + data.newItem + ".png') }}";
              itemEl.classList.remove("hidden");
              slotEl.classList.add("filled");
              return;
            }
            else return true; //Move on to next item
          });
          if (active.items.every(item => item)) active.fighters.forEach(fighter => {
            for (let move in fighter.moves) {
              let moveObj = fighter.moves[move];
              if (moveObj.type == "addItem") unselectable(moveObj);
            }
          });
        }

        else if (data.move.type == "revive") {
          let revived = active.defeated[0];
          fighters.push(revived);
          defeated = fighters.filter(fighter => fighter != revived);
          active.fighters.push(revived);
          active.defeated = fighters.filter(fighter => fighter != revived);
          revived.hp = 1;
          revived.el.classList.remove("defeated");
          createFighter(revived, revived.el);
          unselectable(data.move);
        }

        else {
          data.targets.forEach((target, i) => {
            if (data.damage[i] >= target.hp && data.selfDamage >= data.sender.hp) winnerOverride = active; //If both players lose at the same time, the sender is the winner
            if (data.damage[i]) damage(target, data.damage[i]);
            if (data.selfDamage > 0) damage(data.sender, data.selfDamage);
            else if (data.selfDamage < 0) heal(data.sender, -data.selfDamage);
            if (data.teammateDamage) damage(data.senderTeammate, data.selfDamage);
            if (data.poison[i]) {
              addEffect("poison", target, data.move.poisonDuration);
              if (target.effects.effectRevenge) addEffect("poison", data.sender, data.move.poisonDuration);
            }
            if (data.disorient[i]) {
              addEffect("disoriented", target, data.move.disorientDuration);
              if (target.effects.effectRevenge) addEffect("disoriented", data.sender, data.move.disorientDuration);
            }
            if (data.stun[i]) {
              addEffect("stunned", target, data.move.stunDuration);
              if (target.effects.effectRevenge) addEffect("stunned", data.sender, data.move.stunDuration);
            }
          });

          //Attack animation
          let root = document.documentElement;
          if (data.sender.team == 1) root.style.setProperty("--attack-x", "4px");
          else root.style.setProperty("--attack-x", "-4px");
          if (data.targets.length == 1 && data.sender.name.includes("a") && data.targets[0].name.includes("b")) root.style.setProperty("--attack-y", "4px");
          else if (data.targets.length == 1 && data.sender.name.includes("b") && data.targets[0].name.includes("a")) root.style.setProperty("--attack-y", "-4px");
          else root.style.setProperty("--attack-y", "0");
          data.sender.el.classList.add("attack");
          setTimeout(() => data.sender.el.classList.remove("attack"), 400);
        }
      }

      endTurn();
    }

    function pickUpItem(item, slot) {
      let itemObj = items[item];
      let itemEl = document.getElementById("p" + me.team + "-item" + slot);
      let slotEl = document.getElementById("p" + me.team + "-itemSlot" + slot);
      let containerEl = document.getElementById("p" + me.team + "-items");
      removeTargetOptions();
      itemEl.classList.add("hidden");
      slotEl.classList.remove("filled");
      containerEl.ondragover = function() {itemDraggedOver(this);};
      containerEl.ondragleave = function() {this.style.filter = null;};
      containerEl.ondrop = () => cancelItem(itemEl, slotEl);
      containerEl.classList.add("droppable");
      if (["heal", "attackBoost", "shield"].includes(item)) {
        showInstructions("Drag to target");
        me.fighters.forEach(fighter => {
          let targetOption = true;
          if (item == "heal" && fighter.hp == 100) targetOption = false;
          else if (item == "attackBoost" && fighter.effects.attackBoost == itemObj.duration) targetOption = false;
          else if (item == "shield" && fighter.effects.shield == itemObj.duration) targetOption = false;
          if (targetOption) {
            fighter.el.ondragover = function() {itemDraggedOver(this);};
            fighter.el.ondragleave = function() {this.style.filter = null;};
            fighter.el.ondrop = () => useItem(item, fighter, slot, fighter);
            fighter.el.classList.add("droppable");
          }
        });
      } else {
        let target;
        if (item == "cleanse") target = me;
        else target = opponent;
        let usable = true;
        if (item == "fastTimer" && target.effects.fastTimer == itemObj.duration) usable = false;
        if (item == "skipTurn" && target.effects.skipTurn == itemObj.duration) usable = false;
        if (item == "noItems" && target.effects.noItems == itemObj.duration) usable = false;
        if (item == "cleanse" && !me.effects.fastTimer && !me.effects.noItems && !me.fighters.some(fighter => fighter.effects.poison || fighter.effects.disoriented || fighter.effects.stunned)) usable = false; //"Cleanse" item is unusable if player and all their fighters have no negative effects
        if (usable) {
          document.body.ondragover = () => event.preventDefault(); //Allow dropping
          document.body.ondrop = () => useItem(item, target, slot);
          showInstructions("Drag anywhere to use");
        }
        else document.body.ondrop = () => cancelItem(itemEl, slotEl);
      }
    }

    function itemDraggedOver(el) {
      event.preventDefault(); //Allow dropping
      el.style.filter = "drop-shadow(0 0 6px white)";
    }

    function cancelItem(itemEl, slotEl) {
      itemEl.classList.remove("hidden");
      slotEl.classList.add("filled");
      removeItemtargets();
    }

    function useItem(item, target, slot, fighter) {
      let itemObj = items[item];
      document.getElementById("p" + me.team + "-item" + slot).ondragend = null;
      if (fighter) fighter.el.style.filter = null;
      removeItemtargets();
      sendMessage(me.name + " used the \"" + itemObj.name + "\" item.");
      ws.send(JSON.stringify({
        type: "fighter",
        to: opponent.name,
        from: me.name,
        content: {
          match: matchCode,
          type: "item",
          item: item,
          target: target,
          slot: slot
        }
      }));

      /*//for testing
      receiveItem({
        item: item,
        target: target,
        slot: slot
      });
      ///et*/
    }

    function removeItemtargets() {
      let containerEl = document.getElementById("p" + me.team + "-items");
      containerEl.style.filter = null;
      containerEl.classList.remove("droppable");
      me.fighters.forEach(fighter => {
        fighter.el.ondragover = null;
        fighter.el.ondragleave = null;
        fighter.el.ondrop = null;
        fighter.el.classList.remove("droppable");
      });
      document.body.ondrop = null;
      document.body.ondragover = null;
      hideInstructions();
    }

    function receiveItem(data) {
      let itemObj = items[data.item];

      if (data.item == "heal") heal(data.target, 30);
      else if (data.item == "cleanse") cleanse(data.target);
      else addEffect(data.item, data.target, itemObj.duration);
      active.items[data.slot] = null;
      document.getElementById("p" + active.team + "-item" + data.slot).classList.add("hidden");
      active.fighters.forEach(fighter => {
        for (let move in fighter.moves) {
          let moveObj = fighter.moves[move];
          if (moveObj.type == "addItem") removeUnselectable(moveObj);
        }
      });
      if (active == me) enableMoves(me); //Re-enable items. If one fighter has an "add item" move, this will make it usable.
    }

    function damage(target, amount) {
      let changeEl = document.getElementById(target.name + "-HPNumChange");
      changeEl.style.color = "var(--color-red)";
      changeEl.innerText = "−" + amount;
      changeEl.classList.add("showHPChange");
      function decreaseHP() {
        setTimeout(() => {
          document.getElementById(target.name + "-HPNum").innerText = --target.hp;
          fillHPBar(target, document.getElementById(target.name + "-HPBar"));
          if (!target.hp) defeat(target);
          else if (--amount) decreaseHP(); //Repeat this function until amount is 0
        }, 10);
      }
      decreaseHP();
      setTimeout(() => changeEl.classList.remove("showHPChange"), 1500);
    }

    function heal(target, amount) {
      let changeEl = document.getElementById(target.name + "-HPNumChange");
      changeEl.style.color = "var(--color-green)";
      changeEl.innerText = "+" + amount;
      changeEl.classList.add("showHPChange");
      function increaseHP() {
        setTimeout(() => {
          if (target.hp < 100) {
            document.getElementById(target.name + "-HPNum").innerText = ++target.hp;
            fillHPBar(target, document.getElementById(target.name + "-HPBar"));
            if (--amount) increaseHP(); //Repeat this function until amount is 0
          }
        }, 10);
      }
      increaseHP();
      setTimeout(() => changeEl.classList.remove("showHPChange"), 1500);
    }

    function defeat(target) {
      for (let effect in target.effects) removeEffect(effect, target);
      let targetTeammate = getTeammate(target);
      if (targetTeammate?.color == "yellow") unselectable(targetTeammate.moves.other); ////!doesn't always work
      fighters.splice(fighters.indexOf(target), 1);
      defeated.push(target);
      if (target.team == me.team) {
        me.fighters.splice(me.fighters.indexOf(target), 1);
        me.defeated.push(target);
      } else {
        opponent.fighters.splice(opponent.fighters.indexOf(target), 1);
        opponent.defeated.push(target);
      }
      target.el.classList.add("defeated");
      target.el.innerText = "Defeated";
      sendMessage(target.name + "'s " + capitalize(target.color) + " defeated.");
      if (!me.fighters.length && winnerOverride != me) {
        matchOver = true;
        setTimeout(() => endMatch(opponent), 1000);
      }
      else if (!opponent.fighters.length && winnerOverride != opponent) {
        matchOver = true;
        setTimeout(() => endMatch(me), 1000);
      } else {
        for (let move in targetTeammate.moves) {
          let moveObj = targetTeammate.moves[move];
          if (moveObj.type == "revive" && !moveObj.used) removeUnselectable(moveObj);
        }
      }
    }

    function addEffect(effect, target, duration) {
      let effectEl;
      if (effect == "attackBoost" && !target.effects.attackBoost) changeAttack(target, 1.5);
      else if (effect == "stunned") for (let move in target.moves) unselectable(target.moves[move]);
      target.effects[effect] = duration;
      if (fighters.includes(target)) effectEl = document.getElementById(target.name + "-" + effect);
      else effectEl = document.getElementById("p" + target.team + "-" + effect);
      if (Object.keys(target.effects).length > 4) { //Only possible for fighters, not players
        //Condense all effect elements into one
        let allEffectsEl = document.getElementById(target.name + "-allEffects");
        allEffectsEl.removeAttribute("title");
        let i = Object.keys(target.effects).length;
        for (let effectProperty in target.effects) {
          document.getElementById(target.name + "-" + effectProperty).classList.add("hidden");
          allEffectsEl.classList.remove("hidden");
          //List all effects in title
          allEffectsEl.title += effects[effectProperty].name; ////!correct order
          if (--i) allEffectsEl.title += ", ";
        }
        allEffectsEl.innerText = Object.keys(target.effects).length; //Display the total number of effects
      }
      else effectEl.classList.remove("hidden");
      effectTitle(effect, target);
    }

    function removeEffect(effect, target) {
      let effectEl;
      delete target.effects[effect];
      if (effect == "attackBoost") changeAttack(target, 2/3);
      else if (effect == "stunned") for (let move in target.moves) removeUnselectable(target.moves[move]);
      if (fighters.includes(target)) {
        let allEffectsEl = document.getElementById(target.name + "-allEffects")
        effectEl = document.getElementById(target.name + "-" + effect);
        let i = Object.keys(target.effects).length;
        if (Object.keys(target.effects).length <= 4) {
          for (let effectProperty in target.effects) document.getElementById(target.name + "-" + effectProperty).classList.remove("hidden");
          allEffectsEl.classList.add("hidden");
          effectEl.classList.add("hidden");
        } else {
          allEffectsEl.innerText = Object.keys(target.effects).length;
          allEffectsEl.removeAttribute("title");
          for (let effectProperty in target.effects) {
            allEffectsEl.title += effects[effectProperty].name;
            if (--i) allEffectsEl.title += ", ";
          }
        }
      }
      else {
        effectEl = document.getElementById("p" + target.team + "-" + effect);
        effectEl.classList.add("hidden");
      }
    }

    function changeAttack(target, factor) {
      target.attackFactor *= factor;
      for (let move in target.moves) {
        damageProperties.forEach(property => {
          if (target.moves[move][property]) document.getElementById(target.name + "-" + move + "-" + property).innerText = Math.round(target.moves[move][property] * target.attackFactor);
        });
      }
    }

    function cleanse(player) {
      if (player.effects.fastTimer) {
        removeEffect("fastTimer", player);
        clearInterval(countdown);
        startTimer();
      }
      removeEffect("noItems", player);
      player.fighters.forEach(fighter => {
        removeEffect("poison", fighter);
        removeEffect("disoriented", fighter);
        removeEffect("stunned", fighter);
      });
    }

    function endTurn() {
      clearInterval(countdown);

      //Disable moves and items
      me.fighters.forEach(fighter => {
        for (let move in fighter.moves) {
          let moveObj = fighter.moves[move];
          moveObj.el.classList.remove("enabled");
          moveObj.el.onclick = null;
        }
      });
      me.items.forEach((item, i) => {
        let el = document.getElementById("p" + me.team + "-item" + i);
        el.draggable = false;
        el.classList.remove("draggable");
        el.ondrag = null;
      });
      removeTargetOptions();

      let doNothingEl = document.getElementById("p" + me.team + "-doNothing");
      doNothingEl.classList.remove("enabled");
      doNothingEl.onclick = null;

      if (active == me) active = opponent;
      else active = me;
      if (!matchOver) setTimeout(startTurn, 1000);
    }

    function endMatch(winner) {
      let resultEl = document.getElementById("result");

      document.getElementById("game").classList.add("hidden");
      document.getElementById("matchOver").classList.remove("hidden");

      if (winner == me) {
        resultEl.innerText = "You win!";
        me.wins++;
        me.winStreak++;
        opponent.losses++;
        opponent.winStreak = 0;
      } else {
        resultEl.innerText = "You lose";
        opponent.wins++;
        opponent.winStreak++;
        me.losses++;
        me.winStreak = 0;
      }
      updateStats();
    }

    function rematchButton() {
      let el = document.getElementById("rematchButton");
      el.classList.add("on");
      el.onclick = null;
      me.rematch = true;
      ws.send(JSON.stringify({
        type: "fighter",
        to: opponent.name,
        from: me.name,
        content: {
          match: matchCode,
          type: "rematch"
        }
      }));
      sendMessage(me.name + " wants to rematch.");
    }

    function opponentDisconnected() { ////
      if (opponent.fighters) { //If in match
        sendMessage(opponent.name + " disconnected.");
        document.getElementById("rematchButton").classList.add("unselectable");
        if (!matchOver) {
          matchOver = true;
          endMatch(me);
        }
      } else if (me.team == 1 && !rematchCode) { //If waiting for player
        document.getElementById("opponentStatus").innerText = "Waiting for opponent…"
      } else { //If joining player
        alert(opponent.name + " disconnected.");
        window.location = "/fighter";
      }
    }

    ////delete own matches on disconnect
  </script>
{% endblock %}
